<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Controle de Clientes</title>
    <style>
        /* Estilos gerais */
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f0f8ff;
            color: #333;
        }
        .container {
            width: 100%;
            max-width: 2000px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1, h3 {
            text-align: center;
            color: #0066cc;
        }

        /* Estilos para Inputs e Bot√µes */
        input[type="text"],
        input[type="tel"],
        input[type="date"],
        textarea {
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .input-group-horizontal {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
        .input-group-horizontal input {
            flex: 1;
            min-width: 150px;
            margin-bottom: 0;
        }
        .configurable-input {
            /* Largura ser√° definida pelo JavaScript */
        }
        button {
            background-color: #0066cc;
            color: #fff;
            padding: 10px 20px;
            margin: 5px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            position: relative; /* Necess√°rio para posicionar o badge */
        }
        button:hover {
            background-color: #004d99;
        }

        /* Estilos espec√≠ficos de bot√£o */
        .btn-debito-segurar {
            background-color: #ffcc00; /* Amarelo fraco */
            color: #333; /* Texto escuro para contraste */
        }
        .btn-debito-segurar:hover {
            background-color: #e6b800; /* Amarelo um pouco mais escuro no hover */
        }
        /* Novo estilo para o bot√£o de renovar (Data Atual) */
        .btn-renovar-data-atual {
            background-color: #ffc107; /* Amarelo Bootstrap */
            color: #212529; /* Texto escuro */
            border: 1px solid #ffc107;
        }
        .btn-renovar-data-atual:hover {
            background-color: #e0a800;
            border-color: #d39e00;
        }
        /* Novo estilo para o bot√£o de confirma√ß√£o perigosa (vermelho) */
        .modal-confirm-danger {
            background-color: #dc3545; /* Vermelho */
            color: #fff;
        }
        .modal-confirm-danger:hover {
            background-color: #c82333; /* Vermelho mais escuro */
        }

        /* Estilos da Tabela */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            display: none; /* Escondido por padr√£o, mostrado com JS */
        }
        th, td {
            padding: 10px;
            border: 1px solid #ccc;
            text-align: left;
        }
        /* Flexbox para td com bot√µes */
        td {
            display: flex;
            align-items: center;
            flex-wrap: nowrap; /* Impede quebras de linha inesperadas nos bot√µes */
            gap: 5px;
        }
        td button {
            display: inline-block;
            margin-right: 5px;
            flex-shrink: 0; /* Previne que os bot√µes encolham */
        }
        
        /* Cores das linhas da tabela - Ajustado para maior especificidade */
        tr.avisado {
            background-color: #007bff !important; /* Azul */
            color: white;
        }
        tr.debito {
            background-color: #ffa500 !important; /* Laranja */
        }
        tr.vencendo-hoje {
            background-color: #ffff99 !important; /* Amarelo claro */
        }
        tr.vencido {
            background-color: #ff6666 !important; /* Vermelho claro */
        }

        .center {
            text-align: center;
        }

        /* Estilos de Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .modal button {
            background-color: #0066cc;
            color: #fff;
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .modal button:hover {
            background-color: #004d99;
        }

        /* √çcone de Configura√ß√µes */
        .settings-icon {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 30px;
            cursor: pointer;
            background-color: #0066cc;
            color: white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 999;
            transition: background-color 0.3s;
        }
        .settings-icon:hover {
            background-color: #004d99;
        }
        #settingsArea {
            display: none;
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-top: 30px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #settingsArea label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        #settingsArea input[type="range"],
        #settingsArea input[type="number"] {
            width: calc(100% - 22px);
            margin-bottom: 15px;
        }

        /* Estilo para o badge num√©rico */
        .notification-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: red;
            color: white;
            border-radius: 50%;
            padding: 3px 7px;
            font-size: 0.7em;
            min-width: 15px;
            text-align: center;
            line-height: 1;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
        }

        /* Novo estilo para o bot√£o central de mensagens */
        #centralMessageButton {
            display: block;
            margin: 20px auto; /* Centraliza o bot√£o */
            padding: 15px 30px;
            font-size: 1.2em;
            background-color: #28a745; /* Verde vibrante */
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        #centralMessageButton:hover {
            background-color: #218838;
            transform: translateY(-2px);
        }
        #centralMessageButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Estilos para a nova se√ß√£o de clientes avisados */
        #clientesAvisadosSection {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        #clientesAvisadosList {
            list-style: none;
            padding: 0;
        }
        #clientesAvisadosList li {
            background-color: #e0f2f7; /* Um azul claro para destaque */
            border: 1px solid #b3e5fc;
            margin-bottom: 8px;
            padding: 10px 15px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        #clientesAvisadosList li .client-info {
            flex-grow: 1;
        }
        #clientesAvisadosList li button {
            margin-left: 5px;
            padding: 8px 12px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div id="ultimaAtualizacaoInfo"
        style="position: fixed; top: 10px; right: 10px; font-size: 0.9em; color: #555; background-color: #f9f9f9; padding: 5px 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); z-index: 1001;">
        √öltima Altera√ß√£o: Nunca
    </div>
    <div class="container">
        <h1>Controle de Clientes</h1>
        <button id="centralMessageButton" onclick="enviarProximoClienteVencido()">
            Enviar Mensagem para Pr√≥ximo Vencido
            <span id="badgeCentralMessage" class="notification-badge" style="display:none;"></span>
        </button>
        <button onclick="importarClientes()">Importar Clientes (JSON)</button>
        <button onclick="exportarClientes()">Exportar Clientes (JSON)</button>

        <h3>Adicionar Cliente</h3>
        <div class="input-group-horizontal">
            <input type="date" id="dataInput" class="configurable-input" required>
            <input type="text" id="nomeInput" class="configurable-input" placeholder="Nome do Cliente" required>
            <input type="tel" id="telefoneInput" class="configurable-input" placeholder="Telefone (ex: 11999999999)"
                required>
        </div>
        <div>
            <label>
                <input type="radio" name="produto" value="UniTv" checked> UniTv
            </label>
            <label>
                <input type="radio" name="produto" value="Duplecast"> Duplecast
            </label>
        </div>
        <button onclick="adicionarCliente()">Adicionar Cliente</button>

        <h3>Filtros e A√ß√µes</h3>
        <button onclick="filtrarHoje()">Clientes Vencendo Hoje <span id="badgeHoje" class="notification-badge"
                style="display:none;"></span></button>
        <button onclick="filtrarAmanha()">Clientes Vencendo Amanh√£ <span id="badgeAmanha" class="notification-badge"
                style="display:none;"></span></button>
        <button onclick="filtrarVencidos()">Clientes Vencidos <span id="badgeVencidos" class="notification-badge"
                style="display:none;"></span></button>
        <button onclick="filtrarDebito()">Clientes com D√©bito <span id="badgeDebito" class="notification-badge"
                style="display:none;"></span></button>
        <button onclick="filtrarVerDepois()">Ver Depois <span id="badgeVerDepois" class="notification-badge"
                style="display:none;"></span></button>
        <button onclick="filtrarArquivados()">Arquivados <span id="badgeArquivados" class="notification-badge"
                style="display:none;"></span></button>
        <button onclick="filtrarDesativados()">Clientes Desativados <span id="badgeDesativados"
                class="notification-badge" style="display:none;"></span></button>
        <button onclick="mostrarContagemProdutos()">Produtos</button>
        <button onclick="exibirTodos()">Reexibir Todos</button>
        <button onclick="confirmarLimparTodos()">Limpar Todos</button>
        <button onclick="confirmarDesfazer()">Desfazer √öltima A√ß√£o</button>
        <button onclick="confirmarRefazer()">Refazer √öltima A√ß√£o</button>

        <h3>Pesquisa de Clientes</h3>
        <input type="text" id="searchInput" placeholder="Pesquisar por nome ou telefone" oninput="pesquisarClientes()">
        <button onclick="limparPesquisa()">Limpar Pesquisa</button>

        <table>
            <thead>
                <tr>
                    <th>Data de Vencimento</th>
                </tr>
            </thead>
            <tbody id="tabelaClientes"></tbody>
        </table>
        <button onclick="compartilharWhatsApp()">Compartilhar no WhatsApp</button>

        <hr>
        <div id="clientesAvisadosSection">
            <h3>Clientes Avisados (WhatsApp) <span id="badgeOcultos" class="notification-badge"
                    style="display:none;"></span></h3>
            <ul id="clientesAvisadosList">
            </ul>
        </div>
        <hr>
        <h3>Data Atual</h3>
        <p id="dataAtual"></p>

        <div class="settings-icon" onclick="toggleSettingsArea()" title="Ajustes">‚öôÔ∏è</div>
        <div id="settingsArea">
            <h3>Ajustes de Interface</h3>
            <p>Defina o tamanho das caixas de entrada de Data, Nome e Telefone.</p>

            <div>
                <label for="inputWidth">Largura dos Inputs (em %): <span id="inputWidthValue"></span></label>
                <input type="range" id="inputWidth" min="10" max="100" value="16"
                    oninput="updateInputWidth(this.value)">
            </div>
            <button onclick="saveSettings()">Salvar Ajustes</button>
            <button onclick="resetSettings()">Redefinir Padr√£o</button>
        </div>

        <div id="modalConfirmacao" class="modal">
            <div class="modal-content">
                <h3>Confirmar Duplica√ß√£o</h3>
                <p>Voc√™ tem certeza que deseja duplicar este cliente?</p>
                <button onclick="confirmarDuplicacao()">Confirmar</button>
                <button onclick="fecharModal()">Cancelar</button>
            </div>
        </div>

        <div id="modalExclusao" class="modal">
            <div class="modal-content">
                <h3>Confirmar Exclus√£o</h3>
                <p>Voc√™ tem certeza que deseja excluir este cliente?</p>
                <button onclick="confirmarExclusao()">Confirmar</button>
                <button onclick="fecharModal()">Cancelar</button>
            </div>
        </div>

        <div id="modalRenovarComDebito" class="modal">
            <div class="modal-content">
                <h3>Renovar com D√©bito?</h3>
                <p>Tem certeza que deseja renovar este cliente e marc√°-lo como D√©bito?</p>
                <button id="btnConfirmarRenovacaoDebito">Confirmar</button>
                <button onclick="fecharModal()">Cancelar</button>
            </div>
        </div>

        <div id="modalConfirmacaoGenerica" class="modal">
            <div class="modal-content">
                <h3 id="modalConfirmacaoGenericaTitulo">Confirma√ß√£o</h3>
                <p id="modalConfirmacaoGenericaMensagem">Tem certeza?</p>
                <button id="btnConfirmacaoGenericaConfirmar">Confirmar</button>
                <button onclick="fecharModal()">Cancelar</button>
            </div>
        </div>

        <div id="modalEdicao" class="modal" style="display: none;"></div>
        <div id="modalAlerta" class="modal" style="display: none;"></div>

        <div id="modalContagemProdutos" class="modal">
            <div class="modal-content">
                <h3>Contagem de Produtos</h3>
                <p>UniTv: <span id="countUniTv">0</span> clientes <button
                        onclick="filtrarPorProduto('UniTv')">Detalhes</button></p>
                <p>Duplecast: <span id="countDuplecast">0</span> clientes <button
                        onclick="filtrarPorProduto('Duplecast')">Detalhes</button></p>
                <button onclick="fecharModal()">Fechar</button>
            </div>
        </div>

        <div id="modalEscolherProduto" class="modal">
            <div class="modal-content">
                <h3>Escolher Tipo de Produto</h3>
                <p>Selecione o tipo de produto para o cliente:</p>
                <button onclick="alterarProdutoClienteConfirm('UniTv')">UniTv</button>
                <button onclick="alterarProdutoClienteConfirm('Duplecast')">Duplecast</button>
                <button onclick="fecharModal()">Cancelar</button>
            </div>
        </div>

        <div id="modalConflitoIdNome" class="modal" style="display: none;">
            <div class="modal-content">
                <h3>Conflito de Cliente por ID</h3>
                <p>O cliente importado possui o mesmo ID final de telefone (<span id="conflitoId"></span>) que um
                    cliente existente, mas os nomes s√£o diferentes.</p>
                <p><b>Cliente Existente:</b> <span id="conflitoNomeExistente"></span></p>
                <p><b>Cliente Importado:</b> <span id="conflitoNomeImportado"></span></p>
                <p>O que deseja fazer?</p>
                <button id="btnConflitoManterExistente">Manter o Existente</button>
                <button id="btnConflitoUsarImportado">Atualizar Cliente Existente</button>
                <button id="btnConflitoManterAmbos">Manter Ambos (Criar Novo Cliente)</button>
                <button onclick="cancelarConflitoIdNome()">Cancelar Importa√ß√£o Deste</button>
            </div>
        </div>
    </div>
    <script>
        let clientes = []; // Inicializado como array vazio, ser√° preenchido por loadClientes()
        let clientesFiltrados = [];
        let clienteIndexParaExcluir = null;
        let clienteIndexParaDuplicar = null;
        let clienteIndexParaRenovarDebito = null;
        let clienteIndexParaAlterarProduto = null;
        let modoExibicaoArquivados = false;
        let modoExibicaoOcultos = false; // Este agora ser√° usado para a se√ß√£o dedicada, n√£o para o filtro principal.
        let modoExibicaoVerDepois = false;
        let modoExibicaoDesativados = false;
        let filtroProduto = null;
        let historicoClientes = [];
        let redoHistory = [];
        const MAX_HISTORY_STATES = 10;
        let confirmActionCallback = null;

        // Vari√°veis para gerenciar o processo de importa√ß√£o com conflitos
        let clientesParaProcessarImportacao = [];
        let currentIndexImportacao = 0;

        // Vari√°veis para o bot√£o de mensagem central
        let clientesVencidosParaMensagem = [];
        let indiceClienteVencidoAtual = 0;

        // Vari√°vel para armazenar o ID do cliente para "Renovar HOJE"
        let clienteIdParaRenovarHoje = null;

        // ====================================================================================
        // NOVO: URL do seu Aplicativo da Web do Google Apps Script
        // *** IMPORTANTE: ESTE √â O URL QUE VOC√ä FORNECEU! ***
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbx1dMoMr7AnK9f8aYEXBlJEgEsrCz8-6qZHk2LtaPxvbsvTn65B9gIxbioMidCHA3L6GA/exec';
        // ====================================================================================

        // Fun√ß√£o auxiliar para enviar requisi√ß√µes ao backend (Apps Script)
        async function sendRequestToBackend(action, data = {}) {
            try {
                const url = `${WEB_APP_URL}?action=${action}`;
                const options = {
                    method: 'POST', // Padr√£o POST para a√ß√µes que modificam dados
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8', // Crucial para o Apps Script interpretar o JSON
                    },
                    body: JSON.stringify(data),
                    muteHttpExceptions: true // Importante para que o fetch n√£o lance erro em 4xx/5xx e possamos ler a resposta do Apps Script
                };

                if (action === 'get_all_clients') {
                    options.method = 'GET';
                    delete options.body; // Requisi√ß√µes GET n√£o devem ter corpo
                }

                const response = await fetch(url, options);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Erro de rede ou servidor (${response.status}):`, errorText);
                    throw new Error(`Erro de rede ou servidor: ${response.status} - ${errorText}`);
                }
                const result = await response.json();
                if (result && result.status === 'error') {
                    throw new Error(result.message || 'Erro desconhecido do backend.');
                }
                return result; // Para getAllClients, isso ser√° o array de clientes. Para outras, o objeto de status.
            } catch (error) {
                console.error('Erro na comunica√ß√£o com o backend:', error);
                exibirAlerta(`Erro ao salvar/carregar dados: ${error.message}. Verifique a conex√£o e o script.`);
                throw error; // Re-lan√ßa para que as fun√ß√µes chamadoras possam lidar
            }
        }

        // --- Fun√ß√£o para atualizar a data e hora da √∫ltima altera√ß√£o de dados ---
        function atualizarUltimaAtualizacao(acao = "dados atualizados", clienteNome = "") {
            const now = new Date();
            const options = {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            };
            const formattedDateTime = now.toLocaleString('pt-BR', options);

            let fullMessage = `√öltima Altera√ß√£o: ${formattedDateTime}`;
            if (clienteNome) {
                // Remove o "(UniTv)" ou "(Duplecast)" do nome para a mensagem
                const nomeLimpoParaMsg = clienteNome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');
                fullMessage += ` - ${nomeLimpoParaMsg} (${acao})`;
            } else {
                fullMessage += ` (${acao})`;
            }

            // Salva a mensagem completa no localStorage
            localStorage.setItem('ultimaAtualizacaoCliente', fullMessage);
            document.getElementById('ultimaAtualizacaoInfo').textContent = fullMessage;

            // Opcional: Loga a mensagem no console para depura√ß√£o
            console.log(fullMessage);
        }
        // --- Fim da fun√ß√£o de atualiza√ß√£o ---
        function salvarEstadoNoHistorico(clearRedo = true) {
            const estadoAtual = JSON.parse(JSON.stringify(clientes));
            historicoClientes.push(estadoAtual);

            if (historicoClientes.length > MAX_HISTORY_STATES) {
                historicoClientes.shift();
            }

            if (clearRedo) {
                redoHistory = [];
            }
        }
        function exibirConfirmacaoGenerica(titulo, mensagem, callback, isDanger = false) {
            const modal = document.getElementById("modalConfirmacaoGenerica");
            const btnConfirmar = document.getElementById("btnConfirmacaoGenericaConfirmar");

            document.getElementById("modalConfirmacaoGenericaTitulo").innerText = titulo;
            document.getElementById("modalConfirmacaoGenericaMensagem").innerHTML = mensagem;
            confirmActionCallback = callback;

            if (isDanger) {
                btnConfirmar.classList.add("modal-confirm-danger");
            } else {
                btnConfirmar.classList.remove("modal-confirm-danger");
            }

            btnConfirmar.onclick = () => {
                if (confirmActionCallback) {
                    confirmActionCallback();
                    confirmActionCallback = null;
                }
                fecharModal();
            };

            modal.style.display = "flex";
            document.addEventListener("keydown", fecharComEsc);
        }
        function fecharModal() {
            document.getElementById("modalConfirmacao").style.display = "none";
            document.getElementById("modalExclusao").style.display = "none";
            document.getElementById("modalRenovarComDebito").style.display = "none";
            document.getElementById("modalConfirmacaoGenerica").style.display = "none";
            document.getElementById("modalConflitoIdNome").style.display = "none";
            document.getElementById("modalContagemProdutos").style.display = "none";
            document.getElementById("modalEscolherProduto").style.display = "none";

            const modalEdicao = document.getElementById("modalEdicao");
            if (modalEdicao) {
                modalEdicao.style.display = "none";
                modalEdicao.innerHTML = "";
                document.removeEventListener("keydown", fecharComEsc);
            }
            const modalAlerta = document.getElementById("modalAlerta");
            if (modalAlerta) {
                modalAlerta.style.display = "none";
                modalAlerta.innerHTML = "";
                document.removeEventListener("keydown", fecharComEscOuEnter);
            }
            clienteIdParaRenovarHoje = null; // Resetar ap√≥s fechar o modal
        }
        function fecharComEsc(event) {
            if (event.key === "Escape") {
                fecharModal();
            }
        }
        function fecharComEscOuEnter(event) {
            if (event.key === "Enter" || event.key === "Escape") {
                fecharModal();
            }
        }
        function exibirAlerta(mensagem) {
            let modalAlerta = document.getElementById("modalAlerta");
            modalAlerta.style.display = "flex";
            modalAlerta.innerHTML = `
                <div class="modal-content">
                    <h3>Aviso</h3>
                    <p>${mensagem}</p>
                    <button onclick="fecharModal()">OK</button>
                </div>
            `;
            document.addEventListener("keydown", fecharComEscOuEnter);
        }
        document.addEventListener('keydown', function (event) {
            if (event.key === "Enter" && document.getElementById("modalExclusao").style.display === "flex") {
                confirmarExclusao();
            }
        });
        async function adicionarCliente() {
            const dataInput = document.getElementById("dataInput").value.trim();
            const nomeInput = document.getElementById("nomeInput").value.trim();
            const telefoneInput = document.getElementById("telefoneInput").value.trim();
            const produtoSelecionado = document.querySelector('input[name="produto"]:checked').value;

            if (!dataInput || !nomeInput || !telefoneInput) {
                return exibirAlerta("Por favor, insira a data, o nome e o telefone do cliente.");
            }

            const telefoneLimpo = telefoneInput.replace(/[^\d]/g, '');
            if (telefoneLimpo.length < 5) {
                return exibirAlerta("O telefone deve ter pelo menos 5 d√≠gitos para gerar o ID.");
            }
            const clienteId = telefoneLimpo.slice(-5); // Pega os √∫ltimos 5 d√≠gitos como ID
            // Verifica se j√° existe um cliente com este ID (telefone final)
            const clienteExistenteComMesmoId = clientes.find(c => c.id === clienteId);
            if (clienteExistenteComMesmoId) {
                // Se encontrar, avisa o usu√°rio e n√£o adiciona
                return exibirAlerta(`J√° existe um cliente com o ID final de telefone ${clienteId} (Nome: ${clienteExistenteComMesmoId.nome}). Por favor, use um telefone final diferente ou edite o cliente existente.`);
            }

            salvarEstadoNoHistorico(); // Salva o estado atual ANTES da modifica√ß√£o

            // A data armazenada ser√° DD/MM/YYYY
            const dataParts = dataInput.split("-"); // Ex: ["2025", "07", "10"]
            const dataFormatadaParaArmazenar = `${dataParts[2]}/${dataParts[1]}/${dataParts[0]}`; // DD/MM/YYYY

            let nomeComProduto = nomeInput;
            if (produtoSelecionado === "UniTv" || produtoSelecionado === "Duplecast") {
                nomeComProduto = `${nomeInput} (${produtoSelecionado})`;
            }

            clientes.push({
                id: clienteId, // NOVO: Adiciona o ID ao cliente
                data: dataFormatadaParaArmazenar, // Armazena como DD/MM/YYYY
                nome: nomeComProduto,
                telefone: telefoneLimpo,
                avisado: false,
                debito: false,
                Produto: produtoSelecionado,
                arquivado: false,
                oculto: false, // Por padr√£o, ao adicionar, n√£o est√° oculto (n√£o foi avisado)
                verDepois: false,
                desativado: false
            });

            document.getElementById("nomeInput").value = "";
            document.getElementById("telefoneInput").value = "";

            await salvarClientes(); // AGORA SALVA NO GOOGLE SHEETS
            exibirTabela(); // Atualiza a tabela principal
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o
            atualizarUltimaAtualizacao("adicionado", nomeInput);
        }
        async function arquivar(index) {
            salvarEstadoNoHistorico();
            let clienteParaArquivar = clientesExibidos[index]; // Note: clientesExibidos refere-se √† tabela principal

            let clienteOriginal = clientes.find(c => c.id === clienteParaArquivar.id); // Usando ID
            if (clienteOriginal) {
                clienteOriginal.arquivado = true;
                clienteOriginal.oculto = false; // Quando arquivado, n√£o est√° mais "oculto por aviso"
                clienteOriginal.verDepois = false;
                clienteOriginal.desativado = false;
            }
            clientesFiltrados = [];
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false; // Resetar para o comportamento de filtro
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela(); // Atualiza a tabela principal
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o
            atualizarUltimaAtualizacao("arquivado", clienteParaArquivar.nome);
        }
        async function desarquivar(index) {
            salvarEstadoNoHistorico();
            // Ao desarquivar de uma lista de "arquivados", o index se refere a clientesExibidos
            let clienteParaDesarquivar = clientesExibidos[index];

            let clienteOriginal = clientes.find(c => c.id === clienteParaDesarquivar.id); // Usando ID
            if (clienteOriginal) {
                clienteOriginal.arquivado = false;
                // Ao desarquivar, ele pode ou n√£o ser oculto, dependendo do estado anterior.
                // N√£o vamos for√ßar 'oculto: false' aqui.
            }
            clientesFiltrados = [];
            modoExibicaoArquivados = true; // Manter no modo arquivados para que a tabela seja atualizada corretamente
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela(); // Atualiza a tabela principal
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o
            atualizarUltimaAtualizacao("desarquivado", clienteParaDesarquivar.nome);
        }
        function filtrarArquivados() {
            clientesFiltrados = [];
            modoExibicaoArquivados = true;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";
            exibirTabela(); // Apenas a tabela principal usar√° este filtro
            exibirClientesAvisados(); // Certifica-se de que a se√ß√£o avisados n√£o seja afetada por este filtro
        }
        // A fun√ß√£o filtrarOcultos n√£o ser√° mais para exibir na tabela principal,
        // mas sim para um caso onde se queira VER apenas a lista de ocultos (se√ß√£o j√° faz isso)
        // ou se o filtro for ativado por um bot√£o antigo (melhor remover o bot√£o "Clientes Avisados (WhatsApp)" do "Filtros e A√ß√µes").
        // Vou manter a fun√ß√£o, mas ela n√£o far√° sentido se a nova se√ß√£o for usada.
        // Se√ß√£o j√° trata os "avisados/ocultos", ent√£o este bot√£o de filtro pode ser redundante.
        // Vamos renomear para `mostrarApenasOcultosPorFiltro` para clareza, caso a funcionalidade seja mantida.
        // No HTML, o bot√£o "Clientes Avisados (WhatsApp)" agora s√≥ tem o badge e n√£o tem mais onclick para filtrar.
        function mostrarApenasOcultosPorFiltro() { // Renomeada de filtrarOcultos
            clientesFiltrados = clientes.filter(cliente => cliente.oculto && !cliente.arquivado && !cliente.verDepois && !cliente.desativado);
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = true; // Mant√©m a flag para exibirTabela
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";
            exibirTabela(); // Exibe na tabela principal, √∫til para uma "revis√£o" de avisados.
            exibirClientesAvisados(); // Atualiza a se√ß√£o, que n√£o muda pelo filtro principal.
        }
        function filtrarVerDepois() {
            clientesFiltrados = [];
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = true;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";
            exibirTabela();
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o tamb√©m
        }
        function filtrarDesativados() {
            clientesFiltrados = [];
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = true;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";
            exibirTabela();
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o tamb√©m
        }
        function filtrarPorProduto(produto) {
            clientesFiltrados = [];
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = produto;
            document.getElementById("searchInput").value = "";
            fecharModal();
            exibirTabela();
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o tamb√©m
        }
        let clientesExibidos = [];

        /**
         * Converte uma data de string "DD/MM/YYYY" para "DD/MM" para exibi√ß√£o.
         * @param {string} dateString - A data no formato "DD/MM/YYYY".
         * @returns {string} A data no formato "DD/MM".
         */
        function formatDateForDisplay(dateString) {
            if (!dateString) return '';
            const parts = dateString.split('/');
            if (parts.length === 3) {
                return `${parts[0]}/${parts[1]}`; // Retorna DD/MM
            }
            // Se o formato n√£o for DD/MM/YYYY, tenta retornar os primeiros 5 caracteres
            // que corresponderiam a DD/MM se a string for parecida com um formato de data.
            return dateString.substring(0, 5); 
        }

        function exibirTabela() {
            const termoPesquisa = document.getElementById("searchInput").value.trim().toLowerCase();

            let clientesParaProcessar;
            if (termoPesquisa !== '') {
                // Ao pesquisar, mostre todos os que correspondem, independente do status oculto/arquivado/etc.
                clientesParaProcessar = clientes.filter(cliente =>
                    (cliente.nome.toLowerCase().includes(termoPesquisa) || cliente.telefone.includes(termoPesquisa))
                );
                // Reseta todos os modos de exibi√ß√£o quando h√° uma pesquisa ativa.
                clientesFiltrados = [];
                modoExibicaoArquivados = false;
                modoExibicaoOcultos = false; // Importante: a pesquisa pode mostrar ocultos
                modoExibicaoVerDepois = false;
                modoExibicaoDesativados = false;
                filtroProduto = null;
            } else if (modoExibicaoArquivados) {
                clientesParaProcessar = clientes.filter(cliente => cliente.arquivado);
            } else if (modoExibicaoVerDepois) {
                clientesParaProcessar = clientes.filter(cliente => cliente.verDepois && !cliente.arquivado && !cliente.oculto && !cliente.desativado);
            } else if (modoExibicaoDesativados) {
                clientesParaProcessar = clientes.filter(cliente => cliente.desativado);
            } else if (filtroProduto) {
                clientesParaProcessar = clientes.filter(cliente => cliente.Produto === filtroProduto && !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado);
            } else if (clientesFiltrados.length > 0) {
                // Se houver filtro ativo (hoje, amanh√£, vencidos, d√©bito)
                // Certifique-se de que os clientes avisados n√£o apare√ßam aqui, a menos que o filtro 'ocultos' esteja ativo
                if (modoExibicaoOcultos) { // Se o filtro 'mostrarApenasOcultosPorFiltro' foi clicado
                    clientesParaProcessar = clientesFiltrados; // clientesFiltrados j√° contem os ocultos
                } else {
                    clientesParaProcessar = clientesFiltrados.filter(cliente => !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado);
                }
            } else {
                // Exibi√ß√£o padr√£o: todos que N√ÉO est√£o arquivados, ocultos, verDepois ou desativados
                clientesParaProcessar = clientes.filter(cliente => !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado);
            }

            clientesExibidos = clientesParaProcessar;
            if (clientesExibidos.length === 0) {
                document.querySelector("table").style.display = "none";
                document.getElementById("tabelaClientes").innerHTML = `<tr><td colspan="1" style="text-align: center; color: gray;">Nenhum cliente para exibir neste filtro.</td></tr>`;
                atualizarContadores();
                return;
            }

            document.querySelector("table").style.display = "table";
            const tabela = document.getElementById("tabelaClientes");
            tabela.innerHTML = "";

            clientesExibidos.sort((a, b) => {
                // Converta para objetos Date para uma compara√ß√£o precisa
                const [diaA, mesA, anoA] = a.data.split("/").map(num => parseInt(num));
                const [diaB, mesB, anoB] = b.data.split("/").map(num => parseInt(num));
                const dataA = new Date(anoA, mesA - 1, diaA);
                const dataB = new Date(anoB, mesB - 1, diaB);
                return dataA - dataB;
            });

            const hoje = new Date();
            const hojeFormatadaDDMMYYYY = hoje.getDate().toString().padStart(2, '0') + "/" +
                (hoje.getMonth() + 1).toString().padStart(2, '0') + "/" +
                hoje.getFullYear();

            clientesExibidos.forEach((cliente, index) => {
                const tr = document.createElement("tr");

                // Assegure que as classes sejam removidas antes de re-aplicar
                tr.classList.remove("avisado", "debito", "vencendo-hoje", "vencido");

                // As propriedades avisado e debito s√£o booleanas (true/false)
                if (cliente.avisado) tr.classList.add("avisado");
                if (cliente.debito) tr.classList.add("debito");

                // L√≥gica para vencido e vencendo-hoje
                const [diaCliente, mesCliente, anoCliente] = cliente.data.split("/").map(num => parseInt(num));
                const dataCliente = new Date(anoCliente, mesCliente - 1, diaCliente); // Data do cliente sem hora
                const hojeSemHora = new Date(hoje.getFullYear(), hoje.getMonth(), hoje.getDate()); // Hoje sem hora

                if (cliente.data === hojeFormatadaDDMMYYYY) {
                    tr.classList.add("vencendo-hoje");
                } else if (dataCliente < hojeSemHora) { // Comparar datas sem a parte da hora
                    tr.classList.add("vencido");
                }
                
                let botoesAcao = '';
                if (modoExibicaoArquivados) {
                    botoesAcao = `
                        <button title="Desarquivar Cliente" onclick="desarquivar(${index})">Desarquivar</button>
                        <button title="Excluir Cliente" onclick="excluir(${index})">‚ùå</button>
                    `;
                } else if (modoExibicaoVerDepois) {
                    botoesAcao = `
                        <button title="Desmarcar Ver Depois" onclick="toggleVerDepois(${index})">Desmarcar</button>
                        <button title="Editar Cliente" onclick="editar(${index})">Edit</button>
                        <button title="Excluir Cliente" onclick="excluir(${index})">‚ùå</button>
                    `;
                } else if (modoExibicaoDesativados) {
                    botoesAcao = `
                        <button title="Reativar Cliente" onclick="toggleDesativado(${index})">Reativar</button>
                        <button title="Excluir Cliente" onclick="excluir(${index})">‚ùå</button>
                    `;
                } else { // Bot√µes para a tabela principal (n√£o avisados, n√£o arquivados, etc.)
                    const nomeExibicaoBase = cliente.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');
                    botoesAcao = `
                        <button title="Duplicar Cliente" onclick="duplicarCliente(${index})">+</button>
                        <button title="Renovar Autom√°tico" onclick="renovarAutomatico(${index})">üîÅ</button>
                        <button title="Renovar com D√©bito (Confirma√ß√£o)"
                                class="btn-debito-segurar"
                                onclick="pedirConfirmacaoRenovacaoDebito(${index})">D√âBITO</button>
                        <button title="Renovar a Partir de Hoje"
                                class="btn-renovar-data-atual"
                                onclick="pedirConfirmacaoRenovarHoje(${index})">RENOVAR HOJE</button>
                        <button title="Marcar/Desmarcar Ver Depois" onclick="toggleVerDepois(${index})">${cliente.verDepois ? "Desmarcar Ver Depois" : "Ver Depois"}</button>
                        <button title="Alterar Produto" onclick="abrirModalAlterarProduto(${index})">Produto</button>
                        <button title="Editar Cliente" onclick="editar(${index})">Edit</button>
                        <button title="Excluir Cliente" onclick="excluir(${index})">‚ùå</button>
                        <button title="Arquivar Cliente" onclick="arquivar(${index})">üìÇ</button>
                        <button title="Desativar Cliente" onclick="toggleDesativado(${index})">Desativar</button>
                    `;
                }

                const nomeExibicaoBase = cliente.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');
                tr.innerHTML = `
                    <td>
                        ${formatDateForDisplay(cliente.data)} <a href="#" onclick="enviarMensagemWhatsApp('${nomeExibicaoBase}', '${cliente.telefone}', ${index}); return false;">
                            ${nomeExibicaoBase} (${cliente.Produto || 'N/I'})
                        </a>
                        ${botoesAcao}
                    </td>
                `;
                tabela.appendChild(tr);
            });
            atualizarContadores();
        }
        // --- NOVA FUN√á√ÉO: Exibir Clientes Avisados na Se√ß√£o Dedicada ---
        function exibirClientesAvisados() {
            const clientesAvisadosList = document.getElementById('clientesAvisadosList');
            clientesAvisadosList.innerHTML = ''; // Limpa a lista existente

            const avisados = clientes.filter(cliente => cliente.oculto && !cliente.arquivado && !cliente.verDepois && !cliente.desativado);

            if (avisados.length === 0) {
                clientesAvisadosList.innerHTML = '<li>Nenhum cliente avisado para exibir.</li>';
                return;
            }

            avisados.sort((a, b) => {
                const [diaA, mesA, anoA] = a.data.split("/").map(num => parseInt(num));
                const [diaB, mesB, anoB] = b.data.split("/").map(num => parseInt(num));
                const dataA = new Date(anoA, mesA - 1, diaA);
                const dataB = new Date(anoB, mesB - 1, diaB);
                return dataA - dataB;
            });

            avisados.forEach(cliente => {
                const li = document.createElement('li');
                const nomeExibicaoBase = cliente.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');
                li.innerHTML = `
                    <div class="client-info">
                        <strong>${nomeExibicaoBase}</strong> (${cliente.Produto || 'N/I'}) - Vencimento: ${formatDateForDisplay(cliente.data)}
                    </div>
                    <div class="client-actions">
                        <button title="Reexibir Cliente (Tira do Avisados)" onclick="toggleOcultoFromAvisados('${cliente.id}')">Reexibir</button>
                        <button title="Duplicar Cliente" onclick="duplicarClienteById('${cliente.id}')">+</button>
                        <button title="Renovar Autom√°tico" onclick="renovarAutomaticoById('${cliente.id}')">üîÅ</button>
                        <button title="Renovar com D√©bito (Confirma√ß√£o)"
                                class="btn-debito-segurar"
                                onclick="pedirConfirmacaoRenovacaoDebitoById('${cliente.id}')">D√âBITO</button>
                        <button title="Renovar a Partir de Hoje"
                                class="btn-renovar-data-atual"
                                onclick="pedirConfirmacaoRenovarHojeById('${cliente.id}')">RENOVAR HOJE</button>
                        <button title="Marcar/Desmarcar Ver Depois" onclick="toggleVerDepoisById('${cliente.id}')">${cliente.verDepois ? "Desmarcar Ver Depois" : "Ver Depois"}</button>
                        <button title="Alterar Produto" onclick="abrirModalAlterarProdutoById('${cliente.id}')">Produto</button>
                        <button title="Editar Cliente" onclick="editarClienteById('${cliente.id}')">Edit</button>
                        <button title="Excluir Cliente" onclick="excluirClienteById('${cliente.id}')">‚ùå</button>
                        <button title="Arquivar Cliente" onclick="arquivarById('${cliente.id}')">üìÇ</button>
                        <button title="Desativar Cliente" onclick="toggleDesativadoById('${cliente.id}')">Desativar</button>
                    </div>
                `;
                clientesAvisadosList.appendChild(li);
            });
        }
        // Nova fun√ß√£o para reexibir/desmarcar oculto diretamente da se√ß√£o de avisados
        async function toggleOcultoFromAvisados(clientId) {
            salvarEstadoNoHistorico();
            const clienteOriginalIndex = clientes.findIndex(c => c.id === clientId);
            if (clienteOriginalIndex !== -1) {
                clientes[clienteOriginalIndex].oculto = false; // Desmarca como oculto
                clientes[clienteOriginalIndex].avisado = false; // Opcional: tamb√©m desmarca como avisado, se desejar
            }
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela(); // Atualiza a tabela principal
            exibirClientesAvisados(); // Remove da lista de avisados
            atualizarUltimaAtualizacao("reexibido", clientes[clienteOriginalIndex].nome);
        }
        // Fun√ß√µes auxiliares para uso dos bot√µes por ID (na se√ß√£o de avisados)
        function duplicarClienteById(clientId) {
            const index = clientes.findIndex(c => c.id === clientId);
            if (index !== -1) {
                const originalClientesExibidos = clientesExibidos;
                clientesExibidos = [clientes[index]]; // Temporariamente define o cliente como o √∫nico exibido
                duplicarCliente(0); // Chama a fun√ß√£o original com index 0
                clientesExibidos = originalClientesExibidos; // Restaura
            }
        }
        function renovarAutomaticoById(clientId) {
            const index = clientes.findIndex(c => c.id === clientId);
            if (index !== -1) {
                const originalClientesExibidos = clientesExibidos;
                clientesExibidos = [clientes[index]];
                renovarAutomatico(0);
                clientesExibidos = originalClientesExibidos;
            }
        }
        function pedirConfirmacaoRenovacaoDebitoById(clientId) {
            const index = clientes.findIndex(c => c.id === clientId);
            if (index !== -1) {
                const originalClientesExibidos = clientesExibidos;
                clientesExibidos = [clientes[index]];
                pedirConfirmacaoRenovacaoDebito(0);
                clientesExibidos = originalClientesExibidos;
            }
        }
        function pedirConfirmacaoRenovarHojeById(clientId) {
            clienteIdParaRenovarHoje = clientId; // Armazena o ID do cliente
            exibirConfirmacaoGenerica(
                "Confirmar Renova√ß√£o HOJE",
                "Tem certeza que deseja renovar a data de vencimento deste cliente para **HOJE**?",
                confirmarRenovarHoje, // Chama a nova fun√ß√£o de confirma√ß√£o
                false // N√£o √© uma a√ß√£o perigosa (vermelha)
            );
        }
        function toggleVerDepoisById(clientId) {
            const index = clientes.findIndex(c => c.id === clientId);
            if (index !== -1) {
                const originalClientesExibidos = clientesExibidos;
                clientesExibidos = [clientes[index]];
                toggleVerDepois(0);
                clientesExibidos = originalClientesExibidos;
            }
        }
        function abrirModalAlterarProdutoById(clientId) {
            const index = clientes.findIndex(c => c.id === clientId);
            if (index !== -1) {
                const originalClientesExibidos = clientesExibidos;
                clientesExibidos = [clientes[index]];
                abrirModalAlterarProduto(0);
                clientesExibidos = originalClientesExibidos;
            }
        }
        function editarClienteById(clientId) {
            const index = clientes.findIndex(c => c.id === clientId);
            if (index !== -1) {
                const originalClientesExibidos = clientesExibidos;
                clientesExibidos = [clientes[index]];
                editar(0);
                clientesExibidos = originalClientesExibidos;
            }
        }
        function excluirClienteById(clientId) {
            const index = clientes.findIndex(c => c.id === clientId);
            if (index !== -1) {
                const originalClientesExibidos = clientesExibidos;
                clientesExibidos = [clientes[index]];
                excluir(0);
                clientesExibidos = originalClientesExibidos;
            }
        }
        function arquivarById(clientId) {
            const index = clientes.findIndex(c => c.id === clientId);
            if (index !== -1) {
                const originalClientesExibidos = clientesExibidos;
                clientesExibidos = [clientes[index]];
                arquivar(0);
                clientesExibidos = originalClientesExibidos;
            }
        }
        function toggleDesativadoById(clientId) {
            const index = clientes.findIndex(c => c.id === clientId);
            if (index !== -1) {
                const originalClientesExibidos = clientesExibidos; // Salva o estado
                clientesExibidos = [clientes[index]]; // Define temporariamente
                toggleDesativado(0); // Chama a fun√ß√£o com o √≠ndice 0 da lista tempor√°ria
                clientesExibidos = originalClientesExibidos; // Restaura
            }
        }

        // --- FIM: NOVA FUN√á√ÉO ---
        function pedirConfirmacaoRenovacaoDebito(index) {
            clienteIndexParaRenovarDebito = index;
            document.getElementById("modalRenovarComDebito").style.display = "flex";
            document.getElementById("btnConfirmarRenovacaoDebito").onclick = () => confirmarRenovacaoComDebito();
        }
        async function renovarAutomatico(index) {
            const cliente = clientesExibidos[index];
            const produtoCliente = cliente.Produto || "N√£o informado";

            if (produtoCliente === "N√£o informado") {
                exibirAlerta("O produto do cliente n√£o est√° informado! Por favor, edite o cliente e defina o produto antes de renovar.");
                return;
            }

            salvarEstadoNoHistorico();
            let clienteOriginal = clientes.find(c => c.id === cliente.id); // Usando ID
            if (clienteOriginal) {
                if (produtoCliente === "Duplecast") {
                    renovarProximoMes(clienteOriginal);
                } else if (produtoCliente === "UniTv") {
                    renovar30(clienteOriginal);
                } else {
                    exibirAlerta("Tipo de produto desconhecido para renova√ß√£o autom√°tica.");
                    return;
                }
                clienteOriginal.debito = false;
                clienteOriginal.oculto = false;
                clienteOriginal.verDepois = false;
                clienteOriginal.desativado = false;
            }
            clientesFiltrados = [];
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela();
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o
            atualizarUltimaAtualizacao("renovado automaticamente", cliente.nome);
        }
        // --- FUN√á√ÉO PARA PEDIR CONFIRMA√á√ÉO DO "RENOVAR HOJE" ---
        function pedirConfirmacaoRenovarHoje(index) {
            const cliente = clientesExibidos[index];
            clienteIdParaRenovarHoje = cliente.id; // Armazena o ID do cliente clicado
            exibirConfirmacaoGenerica(
                "Confirmar Renova√ß√£o HOJE",
                `Tem certeza que deseja renovar a data de vencimento de **${cliente.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '')}** para **HOJE**?`,
                confirmarRenovarHoje, // Chama a nova fun√ß√£o de confirma√ß√£o
                false // N√£o √© uma a√ß√£o perigosa (vermelha)
            );
        }
        // --- FUN√á√ÉO DE CONFIRMA√á√ÉO DO "RENOVAR HOJE" ---
        async function confirmarRenovarHoje() {
            if (clienteIdParaRenovarHoje !== null) {
                salvarEstadoNoHistorico();
                let clienteOriginal = clientes.find(c => c.id === clienteIdParaRenovarHoje);

                if (clienteOriginal) {
                    const hoje = new Date();
                    const hojeFormatada = hoje.getDate().toString().padStart(2, '0') + "/" +
                                          (hoje.getMonth() + 1).toString().padStart(2, '0') + "/" +
                                          hoje.getFullYear();
                    clienteOriginal.data = hojeFormatada;
                    clienteOriginal.debito = false;
                    clienteOriginal.oculto = false;
                    clienteOriginal.verDepois = false;
                    clienteOriginal.desativado = false;

                    clientesFiltrados = [];
                    modoExibicaoArquivados = false;
                    modoExibicaoOcultos = false;
                    modoExibicaoVerDepois = false;
                    modoExibicaoDesativados = false;
                    filtroProduto = null;

                    await salvarClientes(); // SALVA NO GOOGLE SHEETS
                    exibirTabela();
                    exibirClientesAvisados();
                    atualizarUltimaAtualizacao("renovado a partir da data atual", clienteOriginal.nome);
                    exibirAlerta(`Cliente "${clienteOriginal.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '')}" renovado para hoje!`);
                }
                clienteIdParaRenovarHoje = null; // Resetar ap√≥s a a√ß√£o
            }
        }
        // --- FIM: NOVAS FUN√á√ïES ---

        async function confirmarRenovacaoComDebito() {
            if (clienteIndexParaRenovarDebito !== null) {
                salvarEstadoNoHistorico();
                const cliente = clientesExibidos[clienteIndexParaRenovarDebito];
                const produtoCliente = cliente.Produto || "N√£o informado";

                if (produtoCliente === "N√£o informado") {
                    exibirAlerta("O produto do cliente n√£o est√° informado! Por favor, edite o cliente e defina o produto antes de renovar.");
                    fecharModal();
                    return;
                }

                let clienteOriginal = clientes.find(c => c.id === cliente.id); // Usando ID
                if (clienteOriginal) {
                    if (produtoCliente === "Duplecast") {
                        renovarProximoMes(clienteOriginal);
                    } else if (produtoCliente === "UniTv") {
                        renovar30(clienteOriginal);
                    } else {
                        exibirAlerta("Tipo de produto desconhecido para renova√ß√£o autom√°tica.");
                        fecharModal();
                        return;
                    }
                    clienteOriginal.debito = true;
                    clienteOriginal.oculto = false;
                    clienteOriginal.verDepois = false;
                    clienteOriginal.desativado = false;
                }
                clientesFiltrados = [];
                modoExibicaoArquivados = false;
                modoExibicaoOcultos = false;
                modoExibicaoVerDepois = false;
                modoExibicaoDesativados = false;
                filtroProduto = null;
                await salvarClientes(); // SALVA NO GOOGLE SHEETS
                exibirTabela();
                exibirClientesAvisados(); // Atualiza a nova se√ß√£o
                fecharModal();
                clienteIndexParaRenovarDebito = null;
                exibirAlerta("Cliente renovado e marcado como D√âBITO!");
                atualizarUltimaAtualizacao("renovado com d√©bito", cliente.nome);
            }
        }
        function renovar30(clienteObj) {
            clienteObj.data = incrementarData(clienteObj.data, 30);
        }
        function renovarProximoMes(clienteObj) {
            const [dia, mes, ano] = clienteObj.data.split("/").map(num => parseInt(num));
            const dataObj = new Date(ano, mes - 1, dia);

            dataObj.setMonth(dataObj.getMonth() + 1);

            if (dataObj.getDate() !== dia) {
                dataObj.setDate(0);
            }

            clienteObj.data = `${dataObj.getDate().toString().padStart(2, '0')}/${(dataObj.getMonth() + 1).toString().padStart(2, '0')}/${dataObj.getFullYear()}`;
        }
        function incrementarData(data, dias) {
            const [dia, mes, ano] = data.split("/").map(num => parseInt(num));
            const dataObj = new Date(ano, mes - 1, dia);
            dataObj.setDate(dataObj.getDate() + dias);
            return `${dataObj.getDate().toString().padStart(2, '0')}/${(dataObj.getMonth() + 1).toString().padStart(2, '0')}/${dataObj.getFullYear()}`;
        }
        function duplicarCliente(index) {
            clienteIndexParaDuplicar = index;
            document.getElementById("modalConfirmacao").style.display = "flex";
        }

        async function confirmarDuplicacao() {
            if (clienteIndexParaDuplicar !== null) {
                salvarEstadoNoHistorico();
                const clienteOriginal = clientesExibidos[clienteIndexParaDuplicar];

                // Para duplicar, precisamos gerar um NOVO ID √∫nico
                let novoTelefoneBase = clienteOriginal.telefone;
                let novoId = clienteOriginal.id;
                let contadorDuplicacao = 1;
                while (clientes.some(c => c.id === novoId)) {
                    // Tenta criar um ID √∫nico adicionando sufixo ao telefone
                    novoTelefoneBase = clienteOriginal.telefone + '_' + contadorDuplicacao;
                    novoId = novoTelefoneBase.slice(-5);
                    if (novoTelefoneBase.length < 5) {
                        novoId = "DUP" + String(contadorDuplicacao).padStart(3, '0'); // Fallback para ID mais √∫nico
                    } else {
                        novoId = novoTelefoneBase.slice(-5);
                    }
                    contadorDuplicacao++;
                    if (contadorDuplicacao > 100) {
                        exibirAlerta("N√£o foi poss√≠vel gerar um ID √∫nico para a duplica√ß√£o. Tente novamente.");
                        fecharModal();
                        return;
                    }
                }

                const novoCliente = {
                    id: novoId,
                    data: clienteOriginal.data,
                    nome: clienteOriginal.nome + " (C√≥pia)",
                    telefone: novoTelefoneBase,
                    avisado: false,
                    debito: false,
                    Produto: clienteOriginal.Produto || "N√£o informado",
                    arquivado: false,
                    oculto: false,
                    verDepois: false,
                    desativado: false
                };
                clientes.push(novoCliente);
                clientesFiltrados = [];
                modoExibicaoArquivados = false;
                modoExibicaoOcultos = false;
                modoExibicaoVerDepois = false;
                modoExibicaoDesativados = false;
                filtroProduto = null;
                await salvarClientes(); // SALVA NO GOOGLE SHEETS
                exibirTabela();
                exibirClientesAvisados(); // Atualiza a nova se√ß√£o
                fecharModal();
                clienteIndexParaDuplicar = null;
                atualizarUltimaAtualizacao("duplicado", clienteOriginal.nome);
            }
        }
        async function enviarMensagemWhatsApp(clienteNome, clienteTelefone, index) {
            let telefoneParaWhatsApp = clienteTelefone.replace(/\D/g, ''); // Remove todos os n√£o-d√≠gitos
            if (!telefoneParaWhatsApp) {
                exibirAlerta("N√∫mero de telefone inv√°lido!");
                return;
            }

            // Verifica se o n√∫mero j√° come√ßa com '55' (c√≥digo do Brasil)
            // Se n√£o come√ßar, adiciona '55' ao in√≠cio
            if (!telefoneParaWhatsApp.startsWith('55')) {
                telefoneParaWhatsApp = '55' + telefoneParaWhatsApp;
            }

            const cliente = clientesExibidos[index];
            const vencimento = cliente.data; // Data em DD/MM/YYYY
            const hoje = new Date();

            // Converter a data de vencimento para um objeto Date para compara√ß√£o
            const [diaVenc, mesVenc, anoVenc] = vencimento.split("/").map(num => parseInt(num));
            const dataVencimentoObj = new Date(anoVenc, mesVenc - 1, diaVenc);
            
            // Zerar as horas para compara√ß√£o apenas da data
            const hojeSemHora = new Date(hoje.getFullYear(), hoje.getMonth(), hoje.getDate());
            const dataVencimentoSemHora = new Date(dataVencimentoObj.getFullYear(), dataVencimentoObj.getMonth(), dataVencimentoObj.getDate());


            const vencido = dataVencimentoSemHora < hojeSemHora;

            const hora = hoje.getHours();
            let saudacao = "Ol√°";
            if (hora >= 6 && hora < 12) {
                saudacao = "Bom dia";
            } else if (hora >= 12 && hora < 18) {
                saudacao = "Boa tarde";
            } else {
                saudacao = "Boa noite";
            }

            const nomeParaMensagem = clienteNome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');

            let mensagem;
            if (vencido) {
                mensagem = `${saudacao}! Seu plano de TV *est√° vencido* *${vencimento}*. Lembrando que pagando no dia do vencimento o mensal √© de 30 reais,ap√≥s o dia de vencimento o mensal √© de 35 reais.O pagamento via PIX pode ser feito no n√∫mero: *11950912509* (Waldemar Jose Luiz)`;
            } else {
                mensagem = `${saudacao}! Hoje √© o vencimento do seu plano de TV.*Vencimento*: ${cliente.data}O pagamento via PIX pode ser realizado no n√∫mero: *11950912509* (Waldemar Jose Luiz)`;
            }

            const url = `https://wa.me/${telefoneParaWhatsApp}?text=${encodeURIComponent(mensagem)}`;
            const link = document.createElement("a");
            link.href = url;
            link.target = "_blank";
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();

            setTimeout(() => {
                if (link.parentNode) {
                    link.parentNode.removeChild(link);
                }
            }, 100);

            let clienteOriginal = clientes.find(c => c.id === cliente.id);
            if (clienteOriginal) {
                clienteOriginal.oculto = true; // Marcar como oculto quando a mensagem √© enviada
            }
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela(); // Atualiza a tabela principal
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o de avisados
            atualizarUltimaAtualizacao("mensagem WhatsApp enviada", cliente.nome);
        }
        function exportarClientes() {
            const clientesParaExportar = clientes.map(c => ({
                id: c.id,
                data: c.data,
                nome: c.nome,
                telefone: c.telefone,
                avisado: c.avisado || false,
                debito: c.debito || false,
                Produto: c.Produto || "N√£o informado",
                arquivado: c.arquivado || false,
                oculto: c.oculto || false,
                verDepois: c.verDepois || false,
                desativado: c.desativado || false
            }));

            const clientesJson = JSON.stringify(clientesParaExportar, null, 4);
            const blob = new Blob([clientesJson], { type: "application/json" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "clientes.json";
            link.click();
            atualizarUltimaAtualizacao("clientes exportados");
        }
        async function importarClientes(file = null) {
            let fileToImport = file;

            if (!fileToImport) {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.click(); // Abre o seletor de arquivos

                fileToImport = await new Promise(resolve => {
                    input.onchange = (e) => resolve(e.target.files[0]);
                });

                if (!fileToImport) {
                    return; // Usu√°rio cancelou a sele√ß√£o
                }
            }

            const reader = new FileReader();
            reader.onload = async () => {
                try {
                    salvarEstadoNoHistorico(); // Salva o estado atual antes de come√ßar a importa√ß√£o

                    const clientesImportadosRaw = JSON.parse(reader.result);
                    clientesParaProcessarImportacao = clientesImportadosRaw.map(c => {
                        const telefoneLimpo = c.telefone ? String(c.telefone).replace(/[^\d]/g, '') : '';
                        const id = telefoneLimpo.length >= 5 ? telefoneLimpo.slice(-5) : null;

                        const nomeAjustado = c.Produto && !c.nome.includes(`(${c.Produto})`) ?
                            `${c.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '')} (${c.Produto})` :
                            c.nome;
                        return {
                            id: id,
                            data: c.data,
                            nome: nomeAjustado,
                            telefone: telefoneLimpo,
                            avisado: c.avisado || false,
                            debito: c.debito || false,
                            Produto: c.Produto || "N√£o informado",
                            arquivado: c.arquivado || false,
                            oculto: c.oculto || false, // Manter o status oculto carregado do localStorage
                            verDepois: c.verDepois || false,
                            desativado: c.desativado || false
                        };
                    });
                    currentIndexImportacao = 0;
                    let novosClientesAdicionados = 0;
                    let clientesAtualizados = 0;
                    let clientesIgnorados = 0;

                    while (currentIndexImportacao < clientesParaProcessarImportacao.length) {
                        const clienteImportado = clientesParaProcessarImportacao[currentIndexImportacao];

                        if (!clienteImportado.id) {
                            console.warn(`Cliente ignorado na importa√ß√£o por n√£o ter um ID v√°lido (telefone curto):`, clienteImportado);
                            clientesIgnorados++;
                            currentIndexImportacao++;
                            continue;
                        }

                        const indexClienteExistente = clientes.findIndex(c => c.id === clienteImportado.id);

                        if (indexClienteExistente !== -1) {
                            // Cliente com o mesmo ID j√° existe
                            const clienteExistente = clientes[indexClienteExistente];

                            const nomeExistenteBase = clienteExistente.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');
                            const nomeImportadoBase = clienteImportado.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');

                            if (nomeExistenteBase.toLowerCase() !== nomeImportadoBase.toLowerCase()) {
                                // Conflito de nome com mesmo ID, pede decis√£o ao usu√°rio
                                const acao = await perguntarConflitoIdNome(clienteExistente, clienteImportado);

                                if (acao === 'usarImportado') {
                                    clientes[indexClienteExistente] = clienteImportado;
                                    clientesAtualizados++;
                                } else if (acao === 'manterExistente') {
                                    clientesIgnorados++;
                                } else if (acao === 'manterAmbos') { // Handle "Manter Ambos"
                                    let newId = clienteImportado.id;
                                    let counter = 1;
                                    let originalTelefone = clienteImportado.telefone; // Keep original telefone for base
                                    while (clientes.some(c => c.id === newId)) {
                                        const tempTelefone = originalTelefone + '-' + counter; // Append suffix to phone
                                        newId = tempTelefone.slice(-5); // Re-derive ID from suffixed phone
                                        counter++;
                                        if (counter > 1000) { // Safety break
                                            console.error("Could not generate a unique ID for 'Manter Ambos' option.");
                                            break;
                                        }
                                    }
                                    // Create a new client object with the original imported data, but a new unique ID and modified phone
                                    const newClientForBoth = { ...clienteImportado, id: newId, telefone: originalTelefone + '-' + (counter - 1) };
                                    clientes.push(newClientForBoth);
                                    novosClientesAdicionados++;
                                }
                            } else {
                                // Mesmo ID e mesmo nome (base), atualiza a data se a importada for mais recente
                                const [diaExistente, mesExistente, anoExistente] = clienteExistente.data.split("/").map(Number);
                                const dataObjExistente = new Date(anoExistente, mesExistente - 1, diaExistente);

                                const [diaImportado, mesImportado, anoImportado] = clienteImportado.data.split("/").map(Number);
                                const dataObjImportado = new Date(anoImportado, mesImportado - 1, diaImportado);

                                if (dataObjImportado > dataObjExistente) {
                                    clientes[indexClienteExistente] = clienteImportado;
                                    clientesAtualizados++;
                                } else {
                                    // Update other fields even if date is not newer, if they are different.
                                    // This ensures consistency without forcing a date update.
                                    clientes[indexClienteExistente].nome = clienteImportado.nome;
                                    clientes[indexClienteExistente].telefone = clienteImportado.telefone;
                                    clientes[indexClienteExistente].Produto = clienteImportado.Produto;
                                    clientes[indexClienteExistente].avisado = clienteImportado.avisado;
                                    clientes[indexClienteExistente].debito = clienteImportado.debito;
                                    clientes[indexClienteExistente].arquivado = clienteImportado.arquivado;
                                    clientes[indexClienteExistente].oculto = clienteImportado.oculto;
                                    clientes[indexClienteExistente].verDepois = clienteImportado.verDepois;
                                    clientes[indexClienteExistente].desativado = clienteImportado.desativado;
                                    clientesAtualizados++;
                                }
                            }
                        } else {
                            clientes.push(clienteImportado);
                            novosClientesAdicionados++;
                        }
                        currentIndexImportacao++;
                    }

                    clientesFiltrados = [];
                    modoExibicaoArquivados = false;
                    modoExibicaoOcultos = false;
                    modoExibicaoVerDepois = false;
                    modoExibicaoDesativados = false;
                    filtroProduto = null;
                    document.getElementById("searchInput").value = "";

                    await salvarClientes(); // SALVA NO GOOGLE SHEETS
                    exibirTabela(); // Atualiza a tabela principal
                    exibirClientesAvisados(); // Atualiza a nova se√ß√£o
                    exibirAlerta(`Importa√ß√£o conclu√≠da: ${novosClientesAdicionados} novos clientes adicionados, ${clientesAtualizados} clientes atualizados, ${clientesIgnorados} ignorados.`);
                    atualizarUltimaAtualizacao("clientes importados/atualizados por ID");

                } catch (error) {
                    exibirAlerta("Erro ao importar JSON. Verifique o arquivo ou formato.");
                    console.error("Erro ao importar:", error);
                }
            };
            reader.readAsText(fileToImport);
        }
        function perguntarConflitoIdNome(clienteExistente, clienteImportado) {
            return new Promise((resolve, reject) => {
                document.getElementById('conflitoId').textContent = clienteExistente.id;
                document.getElementById('conflitoNomeExistente').textContent = clienteExistente.nome;
                document.getElementById('conflitoNomeImportado').textContent = clienteImportado.nome;

                document.getElementById('modalConflitoIdNome').style.display = 'flex';

                document.getElementById('btnConflitoManterExistente').onclick = () => {
                    fecharModal();
                    resolve('manterExistente');
                };
                document.getElementById('btnConflitoUsarImportado').onclick = () => {
                    fecharModal();
                    resolve('usarImportado');
                };
                // New handler for "Manter Ambos"
                document.getElementById('btnConflitoManterAmbos').onclick = () => {
                    fecharModal();
                    resolve('manterAmbos');
                };
                window.cancelarConflitoIdNome = () => {
                    fecharModal();
                    resolve('cancelar');
                };
            });
        }
        function filtrarHoje() {
            const hoje = new Date();
            const hojeFormatada = hoje.getDate().toString().padStart(2, '0') + "/" +
                (hoje.getMonth() + 1).toString().padStart(2, '0') + "/" +
                hoje.getFullYear();

            // Filtra clientes que vencem hoje E n√£o est√£o ocultos, arquivados, verDepois ou desativados
            clientesFiltrados = clientes.filter(cliente => cliente.data === hojeFormatada && !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado);
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";
            exibirTabela();
            atualizarContadores();
        }
        function filtrarAmanha() {
            const amanha = new Date();
            amanha.setDate(amanha.getDate() + 1);
            const amanhaFormatada = amanha.getDate().toString().padStart(2, '0') + "/" +
                (amanha.getMonth() + 1).toString().padStart(2, '0') + "/" +
                amanha.getFullYear();

            // Filtra clientes que vencem amanh√£ E n√£o est√£o ocultos, arquivados, verDepois ou desativados
            clientesFiltrados = clientes.filter(cliente => cliente.data === amanhaFormatada && !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado);
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";
            exibirTabela();
            atualizarContadores();
        }
        function filtrarVencidos() {
            const hoje = new Date();
            clientesFiltrados = clientes.filter(cliente => {
                const [dia, mes, ano] = cliente.data.split("/").map(num => parseInt(num));
                const dataCliente = new Date(ano, mes - 1, dia);
                const hojeSemHora = new Date(hoje.getFullYear(), hoje.getMonth(), hoje.getDate());

                // Filtra clientes vencidos E n√£o est√£o ocultos, arquivados, verDepois ou desativados
                return dataCliente < hojeSemHora && !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado;
            });
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";
            exibirTabela();
            atualizarContadores();
        }
        function filtrarDebito() {
            // CORRE√á√ÉO: Aplica o filtro de d√©bito corretamente
            clientesFiltrados = clientes.filter(cliente => cliente.debito && !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado);
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";
            exibirTabela();
            atualizarContadores();
        }
        function exibirTodos() {
            clientesFiltrados = [];
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false; // Garante que o modo de filtro de ocultos esteja desativado
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";
            exibirTabela(); // Atualiza a tabela principal
            exibirClientesAvisados(); // Garante que a se√ß√£o avisados seja atualizada
            atualizarContadores();
        }
        function confirmarLimparTodos() {
            exibirConfirmacaoGenerica(
                "Limpar Todos os Clientes",
                "Tem certeza que deseja limpar **TODOS** os clientes? Essa a√ß√£o n√£o pode ser desfeita e os dados ser√£o perdidos permanentemente!",
                limparTodos,
                true
            );
        }
        function confirmarDesfazer() {
            if (historicoClientes.length <= 1) {
                exibirAlerta("N√£o h√° a√ß√µes para desfazer.");
                return;
            }

            const estadoPrevistoAposDesfazer = historicoClientes.length > 1 ?
                JSON.parse(JSON.stringify(historicoClientes[historicoClientes.length - 2])) : [];

            if (estadoPrevistoAposDesfazer.length === 0) {
                exibirConfirmacaoGenerica(
                    "Desfazer √öltima A√ß√£o (CUIDADO!)",
                    "Aten√ß√£o: A pr√≥xima a√ß√£o de desfazer ir√° **LIMPAR TODA A SUA LISTA DE CLIENTES**! Tem certeza que deseja continuar?",
                    desfazer,
                    true
                );
            } else {
                exibirConfirmacaoGenerica(
                    "Desfazer √öltima A√ß√£o",
                    "Tem certeza que deseja desfazer a √∫ltima altera√ß√£o? Isso ir√° reverter a lista de clientes para o estado anterior.",
                    desfazer,
                    false
                );
            }
        }
        function confirmarRefazer() {
            if (redoHistory.length === 0) {
                exibirAlerta("N√£o h√° a√ß√µes para refazer.");
                return;
            }
            exibirConfirmacaoGenerica(
                "Refazer √öltima A√ß√£o",
                "Tem certeza que deseja refazer a √∫ltima a√ß√£o desfeita?",
                refazer,
                false
            );
        }
        async function limparTodos() {
            salvarEstadoNoHistorico();
            try {
                const response = await sendRequestToBackend('clear_all_clients');
                if (response.status === 'success') {
                    clientes = []; // Limpa o array local AP√ìS o sucesso no backend
                    clientesFiltrados = [];
                    modoExibicaoArquivados = false;
                    modoExibicaoOcultos = false;
                    modoExibicaoVerDepois = false;
                    modoExibicaoDesativados = false;
                    filtroProduto = null;
                    document.getElementById("searchInput").value = "";

                    exibirTabela();
                    exibirClientesAvisados();
                    // N√£o precisa chamar salvarClientes() aqui, pois o backend j√° limpou
                    exibirAlerta("Todos os clientes foram limpos!");
                    atualizarUltimaAtualizacao("lista limpa");
                } else {
                    exibirAlerta(`Erro ao limpar clientes: ${response.message}`);
                }
            } catch (e) {
                console.error("Erro ao limpar clientes no Google Sheets:", e);
                exibirAlerta("Erro ao limpar clientes no Google Sheets. Verifique a conex√£o e o script.");
            }
        }
        async function desfazer() {
            if (historicoClientes.length <= 1) {
                exibirAlerta("N√£o h√° a√ß√µes para desfazer.");
                return;
            }

            redoHistory.push(JSON.parse(JSON.stringify(clientes)));

            historicoClientes.pop();
            clientes = JSON.parse(JSON.stringify(historicoClientes[historicoClientes.length - 1]));

            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTodos(); // Chama exibirTodos para reexibir e atualizar ambas as se√ß√µes
            exibirAlerta("√öltima a√ß√£o desfeita!");
            atualizarUltimaAtualizacao("a√ß√£o desfeita");
        }
        async function refazer() {
            if (redoHistory.length === 0) {
                exibirAlerta("N√£o h√° a√ß√µes para refazer.");
                return;
            }

            salvarEstadoNoHistorico(false);
            clientes = redoHistory.pop();
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTodos(); // Chama exibirTodos para reexibir e atualizar ambas as se√ß√µes
            exibirAlerta("√öltima a√ß√£o refeita!");
            atualizarUltimaAtualizacao("a√ß√£o refeita");
        }
        function editar(index) {
            let cliente = clientesExibidos[index]; // Note: clientesExibidos pode ser filtrado, ent√£o o index √© relativo a ele.
            const modalEdicao = document.getElementById("modalEdicao");
            modalEdicao.style.display = "flex";

            const nomeLimpo = cliente.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');

            modalEdicao.innerHTML = `
                <div class="modal-content">
                    <h3>Editar Cliente</h3>
                    <input type="text" id="novoNome" value="${nomeLimpo}" placeholder="Nome"><br><br>
                    <input type="tel" id="novoTelefone" value="${cliente.telefone}" placeholder="Telefone"><br><br>
                    <input type="date" id="novaData" value="${formatarParaInputDate(cliente.data)}"><br><br>

                    <div>
                        <label>
                            <input type="radio" name="editarProduto" value="UniTv" ${cliente.Produto === "UniTv" ? "checked" : ""}> UniTv
                        </label>
                        <label>
                            <input type="radio" name="editarProduto" value="Duplecast" ${cliente.Produto === "Duplecast" ? "checked" : ""}> Duplecast
                        </label>
                    </div>
                    <br>
                    <button id="salvarBtn">Salvar</button>
                    <button onclick="fecharModal()">Cancelar</button>
                </div>
            `;
            document.getElementById("novoNome").focus();
            // Para salvar a edi√ß√£o, precisamos do index original do cliente na array `clientes`
            const originalClienteIndex = clientes.findIndex(c => c.id === cliente.id);
            document.getElementById("salvarBtn").onclick = () => salvarEdicao(originalClienteIndex);

            document.getElementById("novoNome").addEventListener("keydown", (e) => proximoCampo(e, "novoTelefone"));
            document.getElementById("novoTelefone").addEventListener("keydown", (e) => proximoCampo(e, "novaData"));
            document.getElementById("novaData").addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    document.getElementById("salvarBtn").focus();
                }
            });
            document.getElementById("salvarBtn").addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    salvarEdicao(originalClienteIndex);
                }
            });
            document.addEventListener("keydown", fecharComEsc);
        }
        function proximoCampo(event, proximoId) {
            if (event.key === "Enter") {
                event.preventDefault();
                document.getElementById(proximoId)?.focus();
            }
        }
        // `index` agora se refere ao index do cliente na array `clientes` original, n√£o em `clientesExibidos`
        async function salvarEdicao(originalClienteIndex) {
            salvarEstadoNoHistorico();
            const clienteParaAtualizar = clientes[originalClienteIndex]; // Use o index direto na array principal

            let novoNome = document.getElementById("novoNome").value.trim();
            let novoTelefone = document.getElementById("novoTelefone").value.trim();
            let novaData = document.getElementById("novaData").value.trim(); // Esta j√° est√° em YYYY-MM-DD
            let novoProduto = document.querySelector('input[name="editarProduto"]:checked').value;

            if (!novoNome || !novaData) {
                exibirAlerta("Nome e data s√£o obrigat√≥rios!");
                return;
            }

            const telefoneLimpoEditado = novoTelefone.replace(/[^\d]/g, ''); // Garante que o telefone esteja limpo
            if (telefoneLimpoEditado.length < 5) {
                exibirAlerta("O telefone deve ter pelo menos 5 d√≠gitos para gerar o ID.");
                return;
            }
            const novoId = telefoneLimpoEditado.slice(-5);

            // Verifica se o novo ID j√° existe E n√£o √© o ID do pr√≥prio cliente que est√° sendo editado
            if (novoId !== clienteParaAtualizar.id && clientes.some(c => c.id === novoId && c.id !== clienteParaAtualizar.id)) {
                exibirAlerta(`O novo telefone final (${novoId}) j√° est√° em uso por outro cliente. Por favor, escolha um telefone diferente.`);
                return;
            }

            let nomeSemProduto = novoNome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');
            let nomeComNovoProduto = `${nomeSemProduto} (${novoProduto})`;

            clientes[originalClienteIndex].id = novoId; // Atualiza o ID se o telefone mudou
            clientes[originalClienteIndex].nome = nomeComNovoProduto;
            clientes[originalClienteIndex].telefone = telefoneLimpoEditado; // Salva o telefone limpo
            clientes[originalClienteIndex].data = novaData.split("-").reverse().join("/"); // Converte para DD/MM/YYYY para armazenamento
            clientes[originalClienteIndex].Produto = novoProduto;

            // Resetar modos de exibi√ß√£o e filtros para for√ßar uma re-renderiza√ß√£o completa
            clientesFiltrados = [];
            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";

            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela(); // Atualiza a tabela principal
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o de avisados
            fecharModal();
            atualizarUltimaAtualizacao("editado", nomeComNovoProduto);
        }
        function formatarParaInputDate(data) {
            // Esta fun√ß√£o j√° converte DD/MM/YYYY para YYYY-MM-DD
            let [dia, mes, ano] = data.split("/");
            return `${ano}-${mes}-${dia}`;
        }
        function excluir(index) {
            const cliente = clientesExibidos[index]; // Cliente da lista atualmente exibida
            clienteIndexParaExcluir = clientes.findIndex(c => c.id === cliente.id); // Encontra o index na lista principal
            if (clienteIndexParaExcluir !== -1) {
                document.getElementById("modalExclusao").style.display = "flex";
            }
        }
        async function confirmarExclusao() {
            if (clienteIndexParaExcluir !== null) {
                salvarEstadoNoHistorico();
                const clienteParaExcluir = clientes[clienteIndexParaExcluir]; // Pega o cliente do array principal
                const nomeClienteExcluido = clienteParaExcluir.nome;

                try {
                    // Remove do array local primeiro
                    clientes.splice(clienteIndexParaExcluir, 1);
                    // Em seguida, sincroniza o array atualizado com o Sheets
                    const response = await sendRequestToBackend('bulk_update_clients', { clients: clientes });

                    if (response.status === 'success') {
                        clientesFiltrados = [];
                        modoExibicaoArquivados = false;
                        modoExibicaoOcultos = false;
                        modoExibicaoVerDepois = false;
                        modoExibicaoDesativados = false;
                        filtroProduto = null;
                        document.getElementById("searchInput").value = "";

                        exibirTabela();
                        exibirClientesAvisados();
                        fecharModal();
                        clienteIndexParaExcluir = null;
                        atualizarUltimaAtualizacao("exclu√≠do", nomeClienteExcluido);
                    } else {
                        // Se a exclus√£o no backend falhar, voc√™ pode querer reverter a exclus√£o localmente
                        // Ou, mais robusto, re-carregar os clientes do backend para garantir a consist√™ncia
                        clientes.splice(clienteIndexParaExcluir, 0, clienteParaExcluir); // Reinsere se falhar
                        exibirAlerta(`Falha ao excluir cliente: ${response.message}`);
                    }
                } catch (e) {
                    clientes.splice(clienteIndexParaExcluir, 0, clienteParaExcluir); // Reinsere se falhar
                    console.error("Erro ao excluir cliente no Google Sheets:", e);
                    exibirAlerta("Erro ao excluir cliente no Google Sheets. Verifique a conex√£o e o script.");
                }
            }
        }
        async function toggleAvisado(index) {
            salvarEstadoNoHistorico();
            let cliente = clientesExibidos[index]; // Da tabela principal
            let clienteOriginalIndex = clientes.findIndex(c => c.id === cliente.id);
            if (clienteOriginalIndex !== -1) {
                clientes[clienteOriginalIndex].avisado = !clientes[clienteOriginalIndex].avisado;
                // Se marcar como avisado, tamb√©m o torna oculto da tabela principal
                if (clientes[clienteOriginalIndex].avisado) {
                    clientes[clienteOriginalIndex].oculto = true;
                } else {
                    clientes[clienteOriginalIndex].oculto = false;
                }
            }
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela(); // Atualiza a tabela principal
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o
            atualizarUltimaAtualizacao(`status avisado alterado para ${clientes[clienteOriginalIndex].avisado ? 'sim' : 'n√£o'}`, cliente.nome);
        }
        async function toggleDebito(index) {
            salvarEstadoNoHistorico();
            let cliente = clientesExibidos[index];
            let clienteOriginalIndex = clientes.findIndex(c => c.id === cliente.id);
            if (clienteOriginalIndex !== -1) {
                clientes[clienteOriginalIndex].debito = !clientes[originalClienteIndex].debito;
            }
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela();
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o
            atualizarContadores(); // Atualiza os contadores, o badge de d√©bito ser√° atualizado
            atualizarUltimaAtualizacao(`status d√©bito alterado para ${clientes[originalClienteIndex].debito ? 'sim' : 'n√£o'}`, cliente.nome);
        }
        async function toggleVerDepois(index) {
            salvarEstadoNoHistorico();
            let cliente = clientesExibidos[index];
            let clienteOriginalIndex = clientes.findIndex(c => c.id === cliente.id);
            if (clienteOriginalIndex !== -1) {
                clientes[clienteOriginalIndex].verDepois = !clientes[clienteOriginalIndex].verDepois;
                if (clientes[clienteOriginalIndex].verDepois) {
                    clientes[clienteOriginalIndex].oculto = false; // "Ver Depois" n√£o √© "Oculto por aviso"
                    clientes[clienteOriginalIndex].arquivado = false;
                    clientes[clienteOriginalIndex].desativado = false;
                }
            }
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela();
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o
            atualizarUltimaAtualizacao(`status "Ver Depois" alterado para ${clientes[originalClienteIndex].verDepois ? 'sim' : 'n√£o'}`, cliente.nome);
        }
        async function toggleDesativado(index) {
            salvarEstadoNoHistorico();
            let cliente = clientesExibidos[index];
            let clienteOriginalIndex = clientes.findIndex(c => c.id === cliente.id);
            if (clienteOriginalIndex !== -1) {
                clientes[clienteOriginalIndex].desativado = !clientes[clienteOriginalIndex].desativado;
                if (clientes[originalClienteIndex].desativado) {
                    clientes[clienteOriginalIndex].avisado = false;
                    clientes[clienteOriginalIndex].debito = false;
                    clientes[clienteOriginalIndex].oculto = false; // Desativado n√£o √© "Oculto por aviso"
                    clientes[clienteOriginalIndex].verDepois = false;
                    clientes[clienteOriginalIndex].arquivado = false;
                }
            }
            await salvarClientes(); // SALVA NO GOOGLE SHEETS
            exibirTabela();
            exibirClientesAvisados(); // Atualiza a nova se√ß√£o
            atualizarUltimaAtualizacao(`status desativado alterado para ${clientes[originalClienteIndex].desativado ? 'sim' : 'n√£o'}`, cliente.nome);
        }
        function abrirModalAlterarProduto(index) {
            clienteIndexParaAlterarProduto = index;
            document.getElementById('modalEscolherProduto').style.display = 'flex';
        }
        async function alterarProdutoClienteConfirm(novoProduto) {
            if (clienteIndexParaAlterarProduto !== null) {
                salvarEstadoNoHistorico();
                const clienteParaAtualizar = clientesExibidos[clienteIndexParaAlterarProduto];
                let clienteOriginalIndex = clientes.findIndex(c => c.id === clienteParaAtualizar.id);

                if (clienteOriginalIndex !== -1) {
                    let nomeSemProduto = clientes[clienteOriginalIndex].nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');
                    clientes[originalClienteIndex].Produto = novoProduto;
                    clientes[originalClienteIndex].nome = `${nomeSemProduto} (${novoProduto})`;
                }
                clientesFiltrados = [];
                modoExibicaoArquivados = false;
                modoExibicaoOcultos = false;
                modoExibicaoVerDepois = false;
                modoExibicaoDesativados = false;
                filtroProduto = null;
                await salvarClientes(); // SALVA NO GOOGLE SHEETS
                exibirTabela();
                exibirClientesAvisados(); // Atualiza a nova se√ß√£o
                fecharModal();
                clienteIndexParaAlterarProduto = null;
                exibirAlerta(`Produto do cliente alterado para ${novoProduto}!`);
                atualizarUltimaAtualizacao(`produto alterado para ${novoProduto}`, clienteParaAtualizar.nome);
            }
        }
        // FUN√á√ÉO ORIGINAL: function salvarClientes() { localStorage.setItem('clientes', JSON.stringify(clientes)); }
        async function salvarClientes() {
            try {
                // O hist√≥rico `redoHistory` e `historicoClientes` ainda usam o array local.
                // A l√≥gica do Apps Script j√° lida com adicionar/atualizar/deletar.
                const response = await sendRequestToBackend('bulk_update_clients', { clients: clientes });
                if (response.status === 'success') {
                    console.log('Dados sincronizados com o Google Sheets com sucesso!');
                } else {
                    exibirAlerta(`Falha ao sincronizar clientes: ${response.message}`);
                }
            } catch (e) {
                console.error("Erro ao salvar clientes no Google Sheets:", e);
                exibirAlerta("Erro ao salvar clientes no Google Sheets. Verifique a conex√£o e o script.");
            }
        }
        // FUN√á√ÉO ORIGINAL: function loadClientes() { ... }
        async function loadClientes() {
            try {
                const response = await sendRequestToBackend('get_all_clients');
                // O Apps Script retorna diretamente o array de clientes em caso de sucesso no getAllClients
                if (Array.isArray(response)) {
                    clientes = response.map(c => {
                        const telefoneLimpo = String(c.telefone || '').replace(/[^\d]/g, '');
                        const clienteId = telefoneLimpo.length >= 5 ? telefoneLimpo.slice(-5) : null;

                        // Se o backend estiver enviando a data no formato ISO (ex: "2025-07-16T03:00:00.000Z"),
                        // ou YYYY-MM-DD, vamos parse√°-la para DD/MM/YYYY para o objeto cliente local.
                        let dataClienteFormatada = c.data;
                        if (c.data && typeof c.data === 'string') {
                            let datePart = c.data;
                            if (c.data.includes('T')) {
                                datePart = c.data.split('T')[0]; // Pega apenas a parte da data "YYYY-MM-DD"
                            }
                            // Agora, converte de YYYY-MM-DD para DD/MM/YYYY
                            const parts = datePart.split('-');
                            if (parts.length === 3) {
                                dataClienteFormatada = `${parts[2]}/${parts[1]}/${parts[0]}`;
                            }
                        }
                        
                        // Ao carregar, o status 'oculto' pode vir do Google Sheet agora
                        // Se voc√™ deseja que 'oculto' seja sempre 'false' ap√≥s um refresh, mantenha a linha abaixo.
                        // Caso contr√°rio, use c.oculto para manter o estado persistente.
                        // Decida qual comportamento voc√™ prefere. Mantenho 'false' como no seu original.
                        const isOcultoAposRefresh = false;

                        return {
                            id: c.id || clienteId,
                            data: dataClienteFormatada, // Armazena como DD/MM/YYYY
                            nome: c.nome,
                            telefone: telefoneLimpo,
                            avisado: c.avisado || false,
                            debito: c.debito || false,
                            Produto: c.Produto || "N√£o informado",
                            arquivado: c.arquivado || false,
                            oculto: isOcultoAposRefresh,
                            verDepois: c.verDepois || false,
                            desativado: c.desativado || false
                        };
                    }).filter(c => c.id !== null); // Filtra clientes sem ID v√°lido
                    console.log("Clientes carregados do Google Sheets:", clientes);
                } else {
                    console.error("Formato de resposta inv√°lido ao carregar clientes:", response);
                    clientes = [];
                    exibirAlerta("Erro: Formato de dados inv√°lido recebido do Google Sheets.");
                }
            } catch (e) {
                console.error("Erro ao carregar clientes do Google Sheets:", e);
                clientes = []; // Garante que a lista esteja vazia em caso de falha grave
                exibirAlerta("Erro ao carregar clientes do Google Sheets. Verifique a conex√£o e o Apps Script.");
            }

            // A l√≥gica de `ultimaAtualizacaoInfo` ainda pode vir do localStorage
            const ultimaAtualizacaoSalva = localStorage.getItem('ultimaAtualizacaoCliente');
            if (ultimaAtualizacaoSalva) {
                document.getElementById('ultimaAtualizacaoInfo').textContent = ultimaAtualizacaoSalva;
            } else {
                document.getElementById('ultimaAtualizacaoInfo').textContent = `√öltima Altera√ß√£o: Nunca`;
            }
        }
        function compartilharWhatsApp() {
            const url = `https://wa.me/?text=${encodeURIComponent('Ol√°, estou compartilhando esta lista de clientes com voc√™.')}`;
            window.open(url, '_blank');
        }
        function pesquisarClientes() {
            // A pesquisa agora √© tratada diretamente na exibirTabela com base no input
            // N√£o precisamos de l√≥gica de filtro separada aqui, apenas for√ßar a atualiza√ß√£o da tabela
            exibirTabela();
            exibirClientesAvisados(); // Garante que a se√ß√£o avisados tamb√©m se atualize se for o caso
        }
        function limparPesquisa() {
            document.getElementById("searchInput").value = "";
            exibirTodos(); // Chama exibirTodos para reexibir tudo e atualizar ambas as se√ß√µes
        }
        // --- FUN√á√ïES DE AJUSTES ---
        const SETTINGS_KEY = 'inputSettings';
        const DEFAULT_INPUT_WIDTH_PERCENT = 16;
        function toggleSettingsArea() {
            const settingsArea = document.getElementById('settingsArea');
            if (settingsArea.style.display === 'block') {
                settingsArea.style.display = 'none';
            } else {
                settingsArea.style.display = 'block';
                loadSettings();
            }
        }
        function applyInputWidth(widthPercent) {
            const inputs = document.querySelectorAll('.configurable-input');
            inputs.forEach(input => {
                input.style.flexBasis = `${widthPercent}%`;
                input.style.maxWidth = `${widthPercent}%`;
                input.style.width = 'auto';
            });
        }
        function updateInputWidth(value) {
            const widthValueSpan = document.getElementById('inputWidthValue');
            widthValueSpan.textContent = `${value}%`;
            applyInputWidth(value);
        }
        function saveSettings() {
            const inputWidth = document.getElementById('inputWidth').value;
            localStorage.setItem(SETTINGS_KEY, JSON.stringify({
                width: inputWidth
            }));
            exibirAlerta("Ajustes salvos com sucesso!");
            toggleSettingsArea();
        }
        function loadSettings() {
            const savedSettings = localStorage.getItem(SETTINGS_KEY);
            let widthToApply = DEFAULT_INPUT_WIDTH_PERCENT;

            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    widthToApply = settings.width || DEFAULT_INPUT_WIDTH_PERCENT;
                } catch (e) {
                    console.error("Erro ao carregar ajustes do localStorage:", e);
                    localStorage.removeItem(SETTINGS_KEY);
                }
            }

            const inputWidthElement = document.getElementById('inputWidth');
            if (inputWidthElement) {
                inputWidthElement.value = widthToApply;
            }
            const inputWidthValueSpan = document.getElementById('inputWidthValue');
            if (inputWidthValueSpan) {
                inputWidthValueSpan.textContent = `${widthToApply}%`;
            }
            applyInputWidth(widthToApply);
        }
        function resetSettings() {
            localStorage.removeItem(SETTINGS_KEY);
            exibirAlerta("Ajustes redefinidos para o padr√£o!");
            loadSettings();
            toggleSettingsArea();
        }
        // --- FIM: FUN√á√ïES DE AJUSTES ---
        // --- Fun√ß√µes de Contadores ---
        function atualizarContadores() {
            const hoje = new Date();
            const hojeFormatada = hoje.getDate().toString().padStart(2, '0') + "/" +
                (hoje.getMonth() + 1).toString().padStart(2, '0') + "/" +
                hoje.getFullYear();

            // Clientes que s√£o exibidos na tabela principal (N√ÉO OCULTOS, ARQUIVADOS, VERDEPOIS, DESATIVADOS)
            const clientesNaTabelaPrincipal = clientes.filter(cliente => !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado);

            const countHoje = clientesNaTabelaPrincipal.filter(cliente => cliente.data === hojeFormatada).length;
            const countAmanha = clientesNaTabelaPrincipal.filter(cliente => {
                const amanha = new Date();
                amanha.setDate(amanha.getDate() + 1);
                const amanhaFormatada = amanha.getDate().toString().padStart(2, '0') + "/" +
                    (amanha.getMonth() + 1).toString().padStart(2, '0') + "/" +
                    amanha.getFullYear();
                return cliente.data === amanhaFormatada;
            }).length;
            const countVencidos = clientesNaTabelaPrincipal.filter(cliente => {
                const [dia, mes, ano] = cliente.data.split("/").map(num => parseInt(num));
                const dataCliente = new Date(ano, mes - 1, dia);
                const hojeSemHora = new Date(hoje.getFullYear(), hoje.getMonth(), hoje.getDate());

                return dataCliente < hojeSemHora;
            }).length;
            const countDebito = clientesNaTabelaPrincipal.filter(cliente => cliente.debito).length;

            // O contador de ocultos agora conta para o badge na nova se√ß√£o.
            const countOcultos = clientes.filter(cliente => cliente.oculto && !cliente.arquivado && !cliente.verDepois && !cliente.desativado).length;
            const countArquivados = clientes.filter(cliente => cliente.arquivado).length;
            const countVerDepois = clientes.filter(cliente => cliente.verDepois).length;
            const countDesativados = clientes.filter(cliente => cliente.desativado).length;

            updateBadge('badgeHoje', countHoje);
            updateBadge('badgeAmanha', countAmanha);
            updateBadge('badgeVencidos', countVencidos);
            updateBadge('badgeDebito', countDebito);
            updateBadge('badgeOcultos', countOcultos); // Badge da nova se√ß√£o
            updateBadge('badgeArquivados', countArquivados);
            updateBadge('badgeVerDepois', countVerDepois);
            updateBadge('badgeDesativados', countDesativados);

            // Atualiza o contador do bot√£o central de mensagens
            const vencidosNaoOcultosParaMensagem = clientes.filter(cliente => {
                const [dia, mes, ano] = cliente.data.split("/").map(Number);
                const dataCliente = new Date(ano, mes - 1, dia);
                const hojeSemHora = new Date(hoje.getFullYear(), hoje.getMonth(), hoje.getDate());
                const hojeFormatada = hoje.getDate().toString().padStart(2, '0') + "/" + (hoje.getMonth() + 1).toString().padStart(2, '0') + "/" + hoje.getFullYear();

                // Considera apenas vencidos OU vencendo hoje, e que N√ÉO est√£o ocultos, arquivados, verDepois ou desativados
                const isVencendoHoje = cliente.data === hojeFormatada;
                const isVencido = dataCliente < hojeSemHora;

                return (isVencendoHoje || isVencido) && !cliente.oculto && !cliente.arquivado && !cliente.verDepois && !cliente.desativado;
            });
            updateBadge('badgeCentralMessage', vencidosNaoOcultosParaMensagem.length);
        }
        function updateBadge(badgeId, count) {
            const badge = document.getElementById(badgeId);
            if (badge) {
                if (count > 0) {
                    badge.textContent = count;
                    badge.style.display = 'inline-block';
                } else {
                    badge.style.display = 'none';
                }
            }
        }
        // --- FIM: Fun√ß√µes de Contadores ---

        function mostrarContagemProdutos() {
            const clientesNaoArquivadosNaoOcultos = clientes.filter(cliente => !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado);
            const countUniTv = clientesNaoArquivadosNaoOcultos.filter(cliente => cliente.Produto === 'UniTv').length;
            const countDuplecast = clientesNaoArquivadosNaoOcultos.filter(cliente => cliente.Produto === 'Duplecast').length;

            document.getElementById('countUniTv').textContent = countUniTv;
            document.getElementById('countDuplecast').textContent = countDuplecast;

            document.getElementById('modalContagemProdutos').style.display = 'flex';
        }
        // --- L√≥gica para o bot√£o central de mensagens ---
        function prepararClientesVencidosParaMensagem() {
            const hoje = new Date();
            const hojeFormatada = hoje.getDate().toString().padStart(2, '0') + "/" +
                (hoje.getMonth() + 1).toString().padStart(2, '0') + "/" +
                hoje.getFullYear();

            clientesVencidosParaMensagem = clientes.filter(cliente => {
                const [dia, mes, ano] = cliente.data.split("/").map(Number);
                const dataCliente = new Date(ano, mes - 1, dia);
                const hojeSemHora = new Date(hoje.getFullYear(), hoje.getMonth(), hoje.getDate());

                // Considera apenas vencidos OU vencendo hoje, e que N√ÉO est√£o ocultos, arquivados, verDepois ou desativados
                const isVencendoHoje = cliente.data === hojeFormatada;
                const isVencido = dataCliente < hojeSemHora;

                return (isVencendoHoje || isVencido) && !cliente.oculto && !cliente.arquivado && !cliente.verDepois && !cliente.desativado;
            }).sort((a, b) => {
                // Opcional: Ordena por data de vencimento (os mais antigos primeiro)
                const [diaA, mesA, anoA] = a.data.split("/").map(num => parseInt(num));
                const [diaB, mesB, anoB] = b.data.split("/").map(num => parseInt(num));
                const dataA = new Date(anoA, mesA - 1, diaA);
                const dataB = new Date(anoB, mesB - 1, diaB);
                return dataA - dataB;
            });
            indiceClienteVencidoAtual = 0;
            atualizarContadores(); // Atualiza o badge do bot√£o central
        }
        function enviarProximoClienteVencido() {
            // Se a lista de clientes vencidos ainda n√£o foi preparada ou est√° vazia, prepara
            if (clientesVencidosParaMensagem.length === 0 || indiceClienteVencidoAtual >= clientesVencidosParaMensagem.length) {
                prepararClientesVencidosParaMensagem();
            }

            if (clientesVencidosParaMensagem.length === 0) {
                exibirAlerta("N√£o h√° clientes vencidos para enviar mensagem no momento.");
                return;
            }

            const cliente = clientesVencidosParaMensagem[indiceClienteVencidoAtual];
            const nomeExibicaoBase = cliente.nome.replace(/\s\(UniTv\)/g, '').replace(/\s\(Duplecast\)/g, '');

            // Envia a mensagem (reutilizando a fun√ß√£o existente)
            // Para garantir que enviarMensagemWhatsApp funcione com o cliente correto,
            // vamos adaptar a chamada para passar o objeto cliente diretamente.
            // A fun√ß√£o `enviarMensagemWhatsApp` original espera um `index` que aponta para `clientesExibidos`.
            // Para evitar modificar `clientesExibidos` globalmente, vamos simular isso para a chamada.
            const originalClientesExibidos = clientesExibidos; // Salva o estado atual de clientesExibidos
            clientesExibidos = [cliente]; // Temporariamente, clientesExibidos tem apenas o cliente atual
            enviarMensagemWhatsApp(nomeExibicaoBase, cliente.telefone, 0); // Chama com index 0 porque `cliente` √© o √∫nico elemento

            clientesExibidos = originalClientesExibidos; // Restaura clientesExibidos

            // Move para o pr√≥ximo cliente
            indiceClienteVencidoAtual++;
            if (indiceClienteVencidoAtual >= clientesVencidosParaMensagem.length) {
                exibirAlerta("Todas as mensagens para clientes vencidos foram enviadas (ou a lista foi percorrida). Clique novamente para recarregar a lista.");
                prepararClientesVencidosParaMensagem(); // Prepara a lista novamente caso queira circular
            }
            atualizarContadores(); // Atualiza o badge ap√≥s o envio
        }
        // --- FIM: L√≥gica para o bot√£o central de mensagens ---
        async function inicializarExibicaoClientes() {
            await loadClientes(); // Await para garantir que os clientes sejam carregados antes de qualquer outra opera√ß√£o

            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            document.getElementById('dataInput').value = `${year}-${month}-${day}`;

            const hojeFormatada = today.getDate().toString().padStart(2, '0') + "/" +
                                  (today.getMonth() + 1).toString().padStart(2, '0') + "/" +
                                  today.getFullYear();

            // Filtra clientes para a exibi√ß√£o inicial: vencendo hoje OU vencidos,
            // E que N√ÉO est√£o arquivados, ocultos, verDepois ou desativados.
            clientesFiltrados = clientes.filter(cliente => {
                const [dia, mes, ano] = cliente.data.split("/").map(num => parseInt(num));
                const dataCliente = new Date(ano, mes - 1, dia);
                const hojeSemHora = new Date(today.getFullYear(), today.getMonth(), today.getDate());

                const isVencendoHoje = cliente.data === hojeFormatada;
                const isVencido = dataCliente < hojeSemHora;

                return (isVencendoHoje || isVencido) && !cliente.arquivado && !cliente.oculto && !cliente.verDepois && !cliente.desativado;
            });

            modoExibicaoArquivados = false;
            modoExibicaoOcultos = false;
            modoExibicaoVerDepois = false;
            modoExibicaoDesativados = false;
            filtroProduto = null;
            document.getElementById("searchInput").value = "";

            exibirTabela();
            exibirClientesAvisados();
            prepararClientesVencidosParaMensagem();
            salvarEstadoNoHistorico(); // Garante o primeiro estado para o hist√≥rico de "desfazer"
            loadSettings();
        }
        // Inicializa√ß√£o
        document.addEventListener('DOMContentLoaded', () => {
            // A data atual sempre ser√° exibida no formato dd/mm/yyyy aqui, pois √© um par√°grafo simples.
            // Se quiser dd/mm aqui tamb√©m, altere a linha abaixo.
            document.getElementById('dataAtual').innerText = new Date().toLocaleDateString('pt-BR');
            inicializarExibicaoClientes();
        });
    </script>
</body>
</html>
